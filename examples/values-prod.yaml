# Production Environment Values
# Use: helm install my-app ./helm-chart -f examples/values-prod.yaml

mode: http
replicaCount: 3

image:
  repository: my-app
  tag: "1.5.2"
  pullPolicy: IfNotPresent

imagePullSecrets:
  - name: registry-credentials

service:
  enabled: true
  type: ClusterIP
  port: 80
  targetPort: 8080
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"

# Ingress configuration for production
ingress:
  enabled: true
  className: nginx
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/rate-limit: "100"
  hosts:
    - host: api.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: api-tls
      hosts:
        - api.example.com

# Production environment variables
env:
  - name: ENVIRONMENT
    value: production
  - name: LOG_LEVEL
    value: info
  - name: NODE_ENV
    value: production
  - name: PORT
    value: "8080"

# Production resources
resources:
  requests:
    cpu: 500m
    memory: 512Mi
  limits:
    cpu: 2000m
    memory: 2Gi

# Production probes
livenessProbe:
  enabled: true
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  enabled: true
  httpGet:
    path: /ready
    port: http
  initialDelaySeconds: 10
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3

startupProbe:
  enabled: true
  httpGet:
    path: /startup
    port: http
  initialDelaySeconds: 0
  periodSeconds: 10
  timeoutSeconds: 3
  failureThreshold: 30

# Enable autoscaling
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 20
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

# Pod disruption budget for high availability
podDisruptionBudget:
  enabled: true
  minAvailable: 2

# Node affinity for production
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/instance
                operator: In
                values:
                  - my-app
          topologyKey: kubernetes.io/hostname

# Security context
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop:
      - ALL

# Production ConfigMap
configMap:
  enabled: true
  data:
    app.config: |
      {
        "environment": "production",
        "logLevel": "info",
        "features": {
          "caching": true,
          "monitoring": true
        },
        "server": {
          "port": 8080,
          "timeout": 30
        }
      }

# Use existing secret in production (created separately)
secret:
  enabled: false
  # Reference existing secrets via envFrom

# Use external secrets
envFrom:
  - secretRef:
      name: app-prod-secrets
  - configMapRef:
      name: '{{ include "universal-app.configMapName" . }}'

# Volumes for production
volumes:
  - name: tmp
    emptyDir: {}
  - name: cache
    emptyDir: {}

volumeMounts:
  - name: tmp
    mountPath: /tmp
  - name: cache
    mountPath: /app/cache

# Service account with RBAC
serviceAccount:
  create: true
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/my-app-role

rbac:
  create: true
  rules:
    - apiGroups: [""]
      resources: ["configmaps"]
      verbs: ["get", "list"]

# Pod annotations for monitoring
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "8080"
  prometheus.io/path: "/metrics"

# Tolerations for specific nodes
tolerations:
  - key: "workload"
    operator: "Equal"
    value: "production"
    effect: "NoSchedule"

# Node selector
nodeSelector:
  environment: production
  workload-type: application
